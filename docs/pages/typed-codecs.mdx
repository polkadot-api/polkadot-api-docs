# Typed Codecs

## Overview

In advanced use cases -mainly for library authors or developer tool creators- itâ€™s often necessary to tap into the **codecs** used in different chain interactions. This is exactly what the `getTypedCodecs` API offers: a **strongly-typed interface** that grants access to all relevant codecs as defined in a chainâ€™s metadata.

This API is particularly helpful when you need to **manually encode or decode values** for runtime storage, calls, constants, or events, without relying on runtime type guessing.

Letâ€™s take a look at how this works in practice.

## Example: Manual Storage Entry Encoding

Suppose you're in a development environment and want to manually set a storage entry for `XcmPallet.Queries`. Hereâ€™s how `getTypedCodecs` helps:

```ts
import { getTypedCodecs } from "polkadot-api"
import {
  dot,
  XcmPalletQueryStatus,
  XcmV4Response,
  XcmVersionedResponse,
} from "@polkadot-api/descriptors"

const codecs = await getTypedCodecs(dot)
const xcmQueriesCodecs = codecs.query.XcmPallet.Queries

export const encodedValue = xcmQueriesCodecs.value.enc(
  XcmPalletQueryStatus.Ready({
    at: 100000,
    response: XcmVersionedResponse.V4(XcmV4Response.Null()),
  }),
)

export const encodedKey = xcmQueriesCodecs.args.enc([100n])
```

You get **fully typed access** to both key and value encoders for any storage item, safely and with full IDE support.

## Example: Inner Enum Variant Codec

Need to access the codec for a specific enum variant, like `XcmPalletQueryStatus.Ready`? You can go even deeper:

```ts
import { getTypedCodecs } from "polkadot-api"
import {
  dot,
  XcmV4Response,
  XcmVersionedResponse,
} from "@polkadot-api/descriptors"

const codecs = await getTypedCodecs(dot)

codecs.query.XcmPallet.Queries.value.inner.Ready.enc({
  at: 100,
  response: XcmVersionedResponse.V4(XcmV4Response.Null()),
})
```

You can directly encode the structure required by the `Ready` variant of the enum. And again, the entire structure is **strongly typed**.

---

ðŸŽ¥ Want to see this in action? Check out this short video to experience the powerful DX this API offers:

<video src="typed-codecs.webm" controls />

---

## Deep Dive: The Codec System

To fully understand `getTypedCodecs`, it's important to grasp the underlying building blocks: **Codec**, **Encoder**, **Decoder**, and **ShapedCodec**.

### What Is a Codec?

In `polkadot-api`, a `Codec` is an interface that groups together a SCALE `Encoder` and a `Decoder`.

#### Encoder

An encoder is simply:

```ts
type Encoder<T> = (value: T) => Uint8Array
```

It **outputs** a SCALE-encoded byte array from a typed value.

#### Decoder

A decoder has this signature:

```ts
type Decoder<T> = (value: Uint8Array | ArrayBuffer | HexString) => T
```

It **accepts** a SCALE-encoded value and **returns** the corresponding decoded structure.

#### The Codec Interface

A `Codec<T>` bundles both encoder and decoder, and also exposes them in two ways:

1. As a tuple:

   ```ts
   const [encoder, decoder] = Vector(u16)
   ```

2. As properties:

   ```ts
   const codec = Vector(u16)

   const encoded = codec.enc([1, 2, 3])
   const decoded = codec.dec(encoded)
   ```

Hereâ€™s the full type:

```ts
type Codec<T> = [Encoder<T>, Decoder<T>] & {
  enc: Encoder<T>
  dec: Decoder<T>
}
```

### The `ShapedCodec` Interface

Some codecs are **primitive** (e.g., `u8`, `bool`, `str`) while others are **complex** (e.g., `Struct`, `Enum`, `Tuple`, `Vector`).

Complex codecs are represented by a `ShapedCodec<T>`, which extends the `Codec<T>` interface with an `inner` property that exposes its componentsâ€”**with full type safety**.

```ts
type ShapedCodec<T> = Codec<T> & {
  inner: SomeMagicTsToInferTheInnerShapeOfThisType<T>
}
```

ðŸ“˜ Curious how the `inner` shape is inferred? [Take a look at the implementation](https://github.com/polkadot-api/polkadot-api/blob/7c0d74f4492277d15a25df732641ab72d7793ffa/packages/client/src/typed-codecs/shaped-codec.ts)

What matters here is: **complex structures like Enums or Structs let you navigate their internal parts**, each fully typed and codec-enabled.

---

## Wrapping Up

The `getTypedCodecs` API provides powerful introspection and manipulation tools for any type defined in your chainâ€™s metadataâ€”without sacrificing type safety or developer ergonomics.

Itâ€™s ideal for:

- Devtools that need precise encoding/decoding logic
- Test tooling that interacts with low-level storage or runtime APIs
- Manual transaction crafting
- Chain simulation and debugging tools

You can use it in combination with [descriptors generated by the CLI](/codegen), and the codecs align 1:1 with the types exposed by the [`TypedApi`](/typed#typedapi).
