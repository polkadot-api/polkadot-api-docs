# API Access

The `PolkadotClient` provides two methods to generate APIs for interacting with the chain's runtime: `getTypedApi` for type-safe operations and `getUnsafeApi` for advanced use cases.

## TypedApi

`getTypedApi` generates a fully type-safe API based on chain descriptors generated by the PAPI CLI.

### Getting Started

First, generate descriptors using the PAPI CLI:

```bash
npx papi add dot -n polkadot
npx papi
```

Then use the descriptors to create a TypedApi:

```ts twoslash
import { createClient } from "polkadot-api"
import { getWsProvider } from "polkadot-api/ws-provider"
import { dot } from "@polkadot-api/descriptors"

const provider = getWsProvider("wss://polkadot-rpc.dwellir.com")
const client = createClient(provider)

// ---cut---
const api = client.getTypedApi(dot)

// Now you have full type-safe access to:
// - api.query.*     - Storage queries
// - api.tx.*        - Transactions
// - api.event.*     - Events
// - api.constants.* - Runtime constants
// - api.apis.*      - Runtime APIs
```

### TypedApi Features

The TypedApi provides access to:

#### Storage Queries

Query on-chain storage with full type safety:

```ts twoslash
import { createClient } from "polkadot-api"
import { getWsProvider } from "polkadot-api/ws-provider"
import { dot } from "@polkadot-api/descriptors"

const provider = getWsProvider("wss://polkadot-rpc.dwellir.com")
const client = createClient(provider)
const api = client.getTypedApi(dot)

// ---cut---
// Single value query
const account = await api.query.System.Account.getValue(
  "5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY",
)

console.log(`Free balance: ${account.data.free}`)

// Multiple values query
const addr1 = "1zugcavYA9yCuYwiEYeMHNJm9gXznYjNfXQjZsZukF1Mpow" as const
const addr2 = "15oF4uVJwmo4TdGW7VfQxNLavjCXviqxT9S1MgbjMNHr6Sp5" as const
const accounts = await api.query.System.Account.getValues([addr1, addr2])
```

See [Storage Queries](/typed/queries) for detailed documentation.

#### Transactions

Create and submit transactions:

```ts twoslash
import { createClient } from "polkadot-api"
import { getWsProvider } from "polkadot-api/ws-provider"
import { dot } from "@polkadot-api/descriptors"

declare const signer: any
const provider = getWsProvider("wss://polkadot-rpc.dwellir.com")
const client = createClient(provider)
const api = client.getTypedApi(dot)

// ---cut---
// Create a transaction
const tx = api.tx.Balances.transfer_keep_alive({
  dest: "5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY",
  value: 1_000_000_000_000n,
})

// Sign and submit
const txHash = await tx.signAndSubmit(signer)

// Or watch the transaction lifecycle
tx.signSubmitAndWatch(signer).subscribe((event) => {
  console.log(`Event: ${event.type}`)
})
```

See [Transactions](/typed/tx) for detailed documentation.

#### Events

Filter and decode events:

```ts twoslash
import { createClient } from "polkadot-api"
import { getWsProvider } from "polkadot-api/ws-provider"
import { dot } from "@polkadot-api/descriptors"

const provider = getWsProvider("wss://polkadot-rpc.dwellir.com")
const client = createClient(provider)
const api = client.getTypedApi(dot)

// ---cut---
const finalizedBlock = await client.getFinalizedBlock()

// Get all transfer events in a block
const transfers = await api.event.Balances.Transfer.pull(finalizedBlock.hash)

transfers.forEach((transfer) => {
  console.log(`Transfer: ${transfer.value.from} -> ${transfer.value.to}`)
  console.log(`Amount: ${transfer.value.amount}`)
})
```

See [Events](/typed/events) for detailed documentation.

#### Runtime Constants

Access compile-time constants:

```ts twoslash
import { createClient } from "polkadot-api"
import { getWsProvider } from "polkadot-api/ws-provider"
import { dot } from "@polkadot-api/descriptors"

const provider = getWsProvider("wss://polkadot-rpc.dwellir.com")
const client = createClient(provider)
const api = client.getTypedApi(dot)

// ---cut---
const blockLength = await api.constants.System.BlockLength()
const existentialDeposit = await api.constants.Balances.ExistentialDeposit()

console.log(`Block length: ${blockLength}`)
console.log(`Existential deposit: ${existentialDeposit}`)
```

See [Constants](/typed/constants) for detailed documentation.

#### Runtime APIs

Call runtime APIs:

```ts twoslash
import { createClient } from "polkadot-api"
import { getWsProvider } from "polkadot-api/ws-provider"
import { dot } from "@polkadot-api/descriptors"

const provider = getWsProvider("wss://polkadot-rpc.dwellir.com")
const client = createClient(provider)
const api = client.getTypedApi(dot)

// ---cut---
const metadata = await api.apis.Metadata.metadata_at_version(15)
const version = await api.apis.Core.version()

console.log(`Runtime version: ${version.specVersion}`)
```

See [Runtime APIs](/typed/apis) for detailed documentation.

### TypedApi Benefits

- **Type Safety**: Full TypeScript type checking for all operations
- **Auto-completion**: IDE support for discovering available pallets, calls, and storage
- **Runtime Compatibility**: Automatically handles runtime version changes
- **Validation**: Catches errors at compile time rather than runtime
- **Documentation**: Type definitions serve as inline documentation

### Multiple Chain Support

Create multiple TypedApi instances for different chains:

```ts twoslash
import { createClient } from "polkadot-api"
import { getWsProvider } from "polkadot-api/ws-provider"
import { dot } from "@polkadot-api/descriptors"
import { ksm } from "@polkadot-api/descriptors"

const polkadotProvider = getWsProvider("wss://polkadot-rpc.dwellir.com")
const kusamaProvider = getWsProvider("wss://kusama-rpc.dwellir.com")

const polkadotClient = createClient(polkadotProvider)
const kusamaClient = createClient(kusamaProvider)

// ---cut---
const polkadotApi = polkadotClient.getTypedApi(dot)
const kusamaApi = kusamaClient.getTypedApi(ksm)

const addr = "1zugcavYA9yCuYwiEYeMHNJm9gXznYjNfXQjZsZukF1Mpow" as const

// Each API is specific to its chain
const dotBalance = await polkadotApi.query.System.Account.getValue(addr)
const ksmBalance = await kusamaApi.query.System.Account.getValue(addr)
```

## UnsafeApi

`getUnsafeApi` provides low-level access to runtime APIs without type safety or compatibility checks.

:::warning
`UnsafeApi` is for advanced users only. It does not provide runtime compatibility protection, and you must handle all version checks and type conversions yourself.
:::

### When to Use UnsafeApi

Use `UnsafeApi` when:

- You need to access runtime APIs not covered by descriptors
- You're building development/debugging tools
- You need maximum flexibility and performance
- You understand the runtime internals

### Basic Usage

```ts twoslash
import { createClient } from "polkadot-api"
import { getWsProvider } from "polkadot-api/ws-provider"

const provider = getWsProvider("wss://polkadot-rpc.dwellir.com")
const client = createClient(provider)

// ---cut---
interface RuntimeApis {
  Core: {
    version: {
      args: []
      value: {
        spec_name: string
        impl_name: string
        authoring_version: number
        spec_version: number
        impl_version: number
      }
    }
  }
  Metadata: {
    metadata_at_version: {
      args: [version: number]
      value: Uint8Array | null
    }
  }
}

const unsafeApi = client.getUnsafeApi<RuntimeApis>()
```

### Calling Runtime APIs

```ts twoslash
import { createClient } from "polkadot-api"
import { getWsProvider } from "polkadot-api/ws-provider"

interface RuntimeApis {
  Core: {
    version: {
      args: []
      value: {
        spec_name: string
        impl_name: string
        authoring_version: number
        spec_version: number
        impl_version: number
      }
    }
  }
}

const provider = getWsProvider("wss://polkadot-rpc.dwellir.com")
const client = createClient(provider)
const unsafeApi = client.getUnsafeApi<RuntimeApis>()

// ---cut---
// Call a runtime API
const version = await unsafeApi.Core.version()

console.log(`Spec name: ${version.spec_name}`)
console.log(`Spec version: ${version.spec_version}`)
```

### Calling with Block Hash

Specify a block to call the API at:

```ts twoslash
import { createClient } from "polkadot-api"
import { getWsProvider } from "polkadot-api/ws-provider"

interface RuntimeApis {
  Core: {
    version: {
      args: []
      value: {
        spec_name: string
        spec_version: number
      }
    }
  }
}

const provider = getWsProvider("wss://polkadot-rpc.dwellir.com")
const client = createClient(provider)
const unsafeApi = client.getUnsafeApi<RuntimeApis>()

// ---cut---
const block = await client.getFinalizedBlock()

// Call at specific block
const version = await unsafeApi.Core.version(block.hash)
```

### Type Definitions

You must define the types yourself:

```ts
interface MyCustomRuntimeApis {
  // Define your runtime APIs here
  MyPallet: {
    my_runtime_call: {
      args: [param1: number, param2: string]
      value: {
        result: boolean
        data: Uint8Array
      }
    }
  }
}

const unsafeApi = client.getUnsafeApi<MyCustomRuntimeApis>()

const result = await unsafeApi.MyPallet.my_runtime_call(42, "test")
```

### UnsafeApi vs TypedApi

| Feature             | TypedApi                  | UnsafeApi                |
| ------------------- | ------------------------- | ------------------------ |
| Type Safety         | ✅ Full                   | ⚠️ Manual                |
| Runtime Checks      | ✅ Automatic              | ❌ None                  |
| Auto-completion     | ✅ Yes                    | ⚠️ Only if types defined |
| Compatibility Check | ✅ Yes                    | ❌ No                    |
| Ease of Use         | ✅ Easy                   | ⚠️ Advanced              |
| Flexibility         | ⚠️ Limited to descriptors | ✅ Unlimited             |

## Comparison Example

Here's how the same operation looks with both APIs:

### With TypedApi (Recommended)

```ts twoslash
import { createClient } from "polkadot-api"
import { getWsProvider } from "polkadot-api/ws-provider"
import { dot } from "@polkadot-api/descriptors"

const provider = getWsProvider("wss://polkadot-rpc.dwellir.com")
const client = createClient(provider)

// ---cut---
const api = client.getTypedApi(dot)

const addr = "1zugcavYA9yCuYwiEYeMHNJm9gXznYjNfXQjZsZukF1Mpow" as const

// ✅ Type-safe, runtime-checked
const balance = await api.query.System.Account.getValue(addr)
console.log(`Balance: ${balance.data.free}`)
```

### With UnsafeApi

```ts twoslash
import { createClient } from "polkadot-api"
import { getWsProvider } from "polkadot-api/ws-provider"

const provider = getWsProvider("wss://polkadot-rpc.dwellir.com")
const client = createClient(provider)

// ---cut---
interface RuntimeApis {
  AccountNonceApi: {
    account_nonce: {
      args: [accountId: string]
      value: number
    }
  }
}

const unsafeApi = client.getUnsafeApi<RuntimeApis>()

// ⚠️ No type checking, no runtime compatibility checks
const nonce = await unsafeApi.AccountNonceApi.account_nonce("address...")
console.log(`Nonce: ${nonce}`)
```

## Best Practices

### 1. Prefer TypedApi

Always use TypedApi unless you have a specific reason to use UnsafeApi:

```ts twoslash
import { createClient } from "polkadot-api"
import { getWsProvider } from "polkadot-api/ws-provider"
import { dot } from "@polkadot-api/descriptors"

const provider = getWsProvider("wss://polkadot-rpc.dwellir.com")
const client = createClient(provider)

// ---cut---
// ✅ Preferred - type-safe and runtime-checked
const api = client.getTypedApi(dot)

// ❌ Avoid unless necessary
const unsafeApi = client.getUnsafeApi()
```

### 2. Reuse API Instances

Create API instances once and reuse them:

```ts twoslash
import { createClient } from "polkadot-api"
import { getWsProvider } from "polkadot-api/ws-provider"
import { dot } from "@polkadot-api/descriptors"

const provider = getWsProvider("wss://polkadot-rpc.dwellir.com")
const client = createClient(provider)

// ---cut---
const addr1 = "1zugcavYA9yCuYwiEYeMHNJm9gXznYjNfXQjZsZukF1Mpow" as const
const addr2 = "15oF4uVJwmo4TdGW7VfQxNLavjCXviqxT9S1MgbjMNHr6Sp5" as const

// ✅ Good - single instance
const api = client.getTypedApi(dot)

await api.query.System.Account.getValue(addr1)
await api.query.System.Account.getValue(addr2)

// ❌ Bad - creating multiple instances
await client.getTypedApi(dot).query.System.Account.getValue(addr1)
await client.getTypedApi(dot).query.System.Account.getValue(addr2)
```

### 3. Handle Runtime Upgrades

Listen for runtime upgrades and recreate APIs if needed:

```ts twoslash
import { createClient } from "polkadot-api"
import { getWsProvider } from "polkadot-api/ws-provider"
import { dot } from "@polkadot-api/descriptors"

const provider = getWsProvider("wss://polkadot-rpc.dwellir.com")
const client = createClient(provider)

// ---cut---
let api = client.getTypedApi(dot)
let previousMetadataLength = 0

client.finalizedBlock$.subscribe(async (block) => {
  const metadata = await client.getMetadata(block.hash)

  if (metadata.length !== previousMetadataLength) {
    console.log("Runtime upgrade detected, recreating API...")
    api = client.getTypedApi(dot)
    previousMetadataLength = metadata.length
  }
})
```

See the [Prepare for Runtime Upgrade recipe](/recipes/upgrade) for more details.

### 4. Use Descriptors for Multiple Chains

Generate and use descriptors for each chain you interact with:

```bash
npx papi add dot -n polkadot
npx papi add ksm -n kusama
npx papi add wnd -n westend
npx papi
```

```ts twoslash
import { createClient } from "polkadot-api"
import { getWsProvider } from "polkadot-api/ws-provider"
import { dot, ksm, wnd } from "@polkadot-api/descriptors"

const dotClient = createClient(getWsProvider("wss://polkadot-rpc.dwellir.com"))
const ksmClient = createClient(getWsProvider("wss://kusama-rpc.dwellir.com"))
const wndClient = createClient(getWsProvider("wss://westend-rpc.dwellir.com"))

// ---cut---
const dotApi = dotClient.getTypedApi(dot)
const ksmApi = ksmClient.getTypedApi(ksm)
const wndApi = wndClient.getTypedApi(wnd)

// Each API is fully typed for its specific chain
```

### 5. Document UnsafeApi Usage

If you must use UnsafeApi, document why and provide clear type definitions:

```ts
/**
 * Using UnsafeApi to access custom runtime API not available in descriptors.
 * This is for the MyCustomPallet runtime API added in runtime version 1234.
 *
 * WARNING: This API is not runtime-compatible. Ensure runtime version >= 1234.
 */
interface CustomRuntimeApis {
  MyCustomPallet: {
    get_special_data: {
      args: [id: number]
      value: {
        data: Uint8Array
        timestamp: number
      }
    }
  }
}

const unsafeApi = client.getUnsafeApi<CustomRuntimeApis>()
```

## Learn More

- [TypedApi Overview](/typed) - Comprehensive TypedApi documentation
- [Storage Queries](/typed/queries) - Querying on-chain storage
- [Transactions](/typed/tx) - Creating and submitting transactions
- [Events](/typed/events) - Working with events
- [Constants](/typed/constants) - Accessing runtime constants
- [Runtime APIs](/typed/apis) - Calling runtime APIs
- [Unsafe API](/unsafe) - Advanced UnsafeApi documentation
